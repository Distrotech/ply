<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <link href='https://fonts.googleapis.com/css?family=Chivo:900' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="stylesheets/pygment_trac.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print" />
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <title>Ply by Distrotech</title>
  </head>

  <body>
    <div id="container">
      <div class="inner">

        <header>
          <h1>Ply</h1>
          <h2>Python Lex-Yacc</h2>
        </header>

        <section id="downloads" class="clearfix">
          <a href="https://github.com/Distrotech/ply/zipball/master" id="download-zip" class="button"><span>Download .zip</span></a>
          <a href="https://github.com/Distrotech/ply/tarball/master" id="download-tar-gz" class="button"><span>Download .tar.gz</span></a>
          <a href="https://github.com/Distrotech/ply" id="view-on-github" class="button"><span>View on GitHub</span></a>
        </section>

        <hr>

        <section id="main_content">
          <p>PLY (Python Lex-Yacc)                   Version 3.5</p>

<p>Copyright (C) 2001-2012,
David M. Beazley (Dabeaz LLC)
All rights reserved.</p>

<p>Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:</p>

<ul>
<li>Redistributions of source code must retain the above copyright notice,
this list of conditions and the following disclaimer.<br>
</li>
<li>Redistributions in binary form must reproduce the above copyright notice, 
this list of conditions and the following disclaimer in the documentation
and/or other materials provided with the distribution.<br>
</li>
<li>Neither the name of the David Beazley or Dabeaz LLC may be used to
endorse or promote products derived from this software without
specific prior written permission. </li>
</ul><p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>

<h1>
<a name="introduction" class="anchor" href="#introduction"><span class="octicon octicon-link"></span></a>Introduction</h1>

<p>PLY is a 100% Python implementation of the common parsing tools lex
and yacc. Here are a few highlights:</p>

<ul>
<li><p>PLY is very closely modeled after traditional lex/yacc.
If you know how to use these tools in C, you will find PLY
to be similar.</p></li>
<li><p>PLY provides <em>very</em> extensive error reporting and diagnostic 
information to assist in parser construction.  The original
implementation was developed for instructional purposes.  As
a result, the system tries to identify the most common types
of errors made by novice users.  </p></li>
<li><p>PLY provides full support for empty productions, error recovery,
precedence specifiers, and moderately ambiguous grammars.</p></li>
<li><p>Parsing is based on LR-parsing which is fast, memory efficient, 
better suited to large grammars, and which has a number of nice
properties when dealing with syntax errors and other parsing problems.
Currently, PLY builds its parsing tables using the LALR(1)
algorithm used in yacc.</p></li>
<li><p>PLY uses Python introspection features to build lexers and parsers.<br>
This greatly simplifies the task of parser construction since it reduces 
the number of files and eliminates the need to run a separate lex/yacc 
tool before running your program.</p></li>
<li><p>PLY can be used to build parsers for "real" programming languages.
Although it is not ultra-fast due to its Python implementation,
PLY can be used to parse grammars consisting of several hundred
rules (as might be found for a language like C).  The lexer and LR 
parser are also reasonably efficient when parsing typically
sized programs.  People have used PLY to build parsers for
C, C++, ADA, and other real programming languages.</p></li>
</ul><h1>
<a name="how-to-use" class="anchor" href="#how-to-use"><span class="octicon octicon-link"></span></a>How to Use</h1>

<p>PLY consists of two files : lex.py and yacc.py.  These are contained
within the 'ply' directory which may also be used as a Python package.
To use PLY, simply copy the 'ply' directory to your project and import
lex and yacc from the associated 'ply' package.  For example:</p>

<pre><code> import ply.lex as lex
 import ply.yacc as yacc
</code></pre>

<p>Alternatively, you can copy just the files lex.py and yacc.py
individually and use them as modules.  For example:</p>

<pre><code> import lex
 import yacc
</code></pre>

<p>The file setup.py can be used to install ply using distutils.</p>

<p>The file doc/ply.html contains complete documentation on how to use
the system.</p>

<p>The example directory contains several different examples including a
PLY specification for ANSI C as given in K&amp;R 2nd Ed.   </p>

<p>A simple example is found at the end of this document</p>

<h1>
<a name="requirements" class="anchor" href="#requirements"><span class="octicon octicon-link"></span></a>Requirements</h1>

<p>PLY requires the use of Python 2.2 or greater.  However, you should
use the latest Python release if possible.  It should work on just
about any platform.  PLY has been tested with both CPython and Jython.
It also seems to work with IronPython.</p>

<h1>
<a name="resources" class="anchor" href="#resources"><span class="octicon octicon-link"></span></a>Resources</h1>

<p>More information about PLY can be obtained on the PLY webpage at:</p>

<pre><code> http://www.dabeaz.com/ply
</code></pre>

<p>For a detailed overview of parsing theory, consult the excellent
book "Compilers : Principles, Techniques, and Tools" by Aho, Sethi, and
Ullman.  The topics found in "Lex &amp; Yacc" by Levine, Mason, and Brown
may also be useful.</p>

<p>A Google group for PLY can be found at</p>

<pre><code> http://groups.google.com/group/ply-hack
</code></pre>

<h1>
<a name="acknowledgments" class="anchor" href="#acknowledgments"><span class="octicon octicon-link"></span></a>Acknowledgments</h1>

<p>A special thanks is in order for all of the students in CS326 who
suffered through about 25 different versions of these tools :-).</p>

<p>The CHANGES file acknowledges those who have contributed patches.</p>

<p>Elias Ioup did the first implementation of LALR(1) parsing in PLY-1.x. 
Andrew Waters and Markus Schoepflin were instrumental in reporting bugs
and testing a revised LALR(1) implementation for PLY-2.0.</p>

<h1>
<a name="special-note-for-ply-30" class="anchor" href="#special-note-for-ply-30"><span class="octicon octicon-link"></span></a>Special Note for PLY-3.0</h1>

<p>PLY-3.0 the first PLY release to support Python 3. However, backwards
compatibility with Python 2.2 is still preserved. PLY provides dual
Python 2/3 compatibility by restricting its implementation to a common
subset of basic language features. You should not convert PLY using
2to3--it is not necessary and may in fact break the implementation.</p>

<h1>
<a name="example" class="anchor" href="#example"><span class="octicon octicon-link"></span></a>Example</h1>

<p>Here is a simple example showing a PLY implementation of a calculator
with variables.</p>

<pre><code># -----------------------------------------------------------------------------
# calc.py
#
# A simple calculator with variables.
# -----------------------------------------------------------------------------

tokens = (
    'NAME','NUMBER',
    'PLUS','MINUS','TIMES','DIVIDE','EQUALS',
    'LPAREN','RPAREN',
    )

# Tokens

t_PLUS    = r'\+'
t_MINUS   = r'-'
t_TIMES   = r'\*'
t_DIVIDE  = r'/'
t_EQUALS  = r'='
t_LPAREN  = r'\('
t_RPAREN  = r'\)'
t_NAME    = r'[a-zA-Z_][a-zA-Z0-9_]*'

def t_NUMBER(t):
    r'\d+'
    t.value = int(t.value)
    return t

# Ignored characters
t_ignore = " \t"

def t_newline(t):
    r'\n+'
    t.lexer.lineno += t.value.count("\n")

def t_error(t):
    print("Illegal character '%s'" % t.value[0])
    t.lexer.skip(1)

# Build the lexer
import ply.lex as lex
lex.lex()

# Precedence rules for the arithmetic operators
precedence = (
    ('left','PLUS','MINUS'),
    ('left','TIMES','DIVIDE'),
    ('right','UMINUS'),
    )

# dictionary of names (for storing variables)
names = { }

def p_statement_assign(p):
    'statement : NAME EQUALS expression'
    names[p[1]] = p[3]

def p_statement_expr(p):
    'statement : expression'
    print(p[1])

def p_expression_binop(p):
    '''expression : expression PLUS expression
                  | expression MINUS expression
                  | expression TIMES expression
                  | expression DIVIDE expression'''
    if p[2] == '+'  : p[0] = p[1] + p[3]
    elif p[2] == '-': p[0] = p[1] - p[3]
    elif p[2] == '*': p[0] = p[1] * p[3]
    elif p[2] == '/': p[0] = p[1] / p[3]

def p_expression_uminus(p):
    'expression : MINUS expression %prec UMINUS'
    p[0] = -p[2]

def p_expression_group(p):
    'expression : LPAREN expression RPAREN'
    p[0] = p[2]

def p_expression_number(p):
    'expression : NUMBER'
    p[0] = p[1]

def p_expression_name(p):
    'expression : NAME'
    try:
        p[0] = names[p[1]]
    except LookupError:
        print("Undefined name '%s'" % p[1])
        p[0] = 0

def p_error(p):
    print("Syntax error at '%s'" % p.value)

import ply.yacc as yacc
yacc.yacc()

while 1:
    try:
        s = raw_input('calc &gt; ')   # use input() on Python 3
    except EOFError:
        break
    yacc.parse(s)
</code></pre>

<h1>
<a name="bug-reports-and-patches" class="anchor" href="#bug-reports-and-patches"><span class="octicon octicon-link"></span></a>Bug Reports and Patches</h1>

<p>My goal with PLY is to simply have a decent lex/yacc implementation
for Python.  As a general rule, I don't spend huge amounts of time
working on it unless I receive very specific bug reports and/or
patches to fix problems. I also try to incorporate submitted feature
requests and enhancements into each new version.  To contact me about
bugs and/or new features, please send email to <a href="mailto:dave@dabeaz.com">dave@dabeaz.com</a>.</p>

<p>In addition there is a Google group for discussing PLY related issues at</p>

<pre><code>http://groups.google.com/group/ply-hack
</code></pre>

<p>-- Dave</p>
        </section>

        <footer>
          Ply is maintained by <a href="https://github.com/Distrotech">Distrotech</a><br>
          This page was generated by <a href="http://pages.github.com">GitHub Pages</a>. Tactile theme by <a href="http://twitter.com/jasonlong">Jason Long</a>.
        </footer>

        
      </div>
    </div>
  </body>
</html>